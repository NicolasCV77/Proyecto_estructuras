#include <iostream>
#include <cstring>
#include <locale>
#include <cstdlib>
#include <fstream>

using namespace std;

typedef void (*CmdFunc)(const string&, const string&);

// Estructura de Comando.
struct Comando {
    string nombre;
    string descripcion;
    int argumentos;
    CmdFunc funcion;
    string uso;
};

// Prototipos de funciones de comando
void ayuda(const string& arg1, const string& arg2);
void comando_cargar(const string& arg1, const string& arg2);
void comando_listar_secuencias(const string& arg1, const string& arg2);
void comando_histograma(const string& arg1, const string& arg2);
void comando_subsecuencia(const string& arg1, const string& arg2);
void comando_enmascarar(const string& arg1, const string& arg2);
void comando_guardar(const string& arg1, const string& arg2);
void comando_codificar(const string& arg1, const string& arg2);
void comando_decodificar(const string& arg1, const string& arg2);
void comando_ruta_mas_corta(const string& arg1, const string& arg2);
void comando_base_remota(const string& arg1, const string& arg2);
void comando_salir(const string& arg1, const string& arg2);

// Tabla de comandos
Comando comandos[] = {   
    {"ayuda", "Muestra todos los comandos", 0, ayuda, "ayuda [comando]"},
    {"cargar", "Carga los datos contenidos en el archivo", 1, comando_cargar, "<nombre_archivo>"},
    {"listar_secuencias", "Lista la cantidad de secuencias", 0, comando_listar_secuencias, "listar_secuencias"},
    {"histograma", "Imprime el histograma de una secuencia", 1, comando_histograma, "<secuencia>"},
    {"es_subsecuencia", "Determina si una subsecuencia existe", 2, comando_subsecuencia, "<secuencia1> <secuencia2>"},
    {"enmascarar", "Enmascara una subsecuencia dada", 2, comando_enmascarar, "<secuencia> <patron>"},
    {"guardar", "Guarda las secuencias en el archivo", 1, comando_guardar, "<nombre_archivo>"},
    {"codificar", "Genera el archivo binario", 2, comando_codificar, "<secuencia> <clave>"},
    {"decodificar", "Cargar las secuencias en el archivo binario", 2, comando_decodificar, "<secuencia_codificada> <clave>"},
    {"ruta_mas_corta", "Calcula ruta mas corta", 2, comando_ruta_mas_corta, "<secuencia1> <secuencia2>"},
    {"base_remota", "Busca la ubicacion de la misma base", 2, comando_base_remota, "<secuencia> <nombre_archivo>"},
    {"salir", "Termina la ejecucion de la aplicacion",0, comando_salir, "salir"}
};

const int numComandos = sizeof(comandos) / sizeof(Comando);

int main() {
    char linea[200];

    cout << "\t~" << endl;
    cout << "\t|          FASTA - TOOL         |" << endl;
    cout << "\t~\t"<< endl;
    cout << endl << "By Mafe Cruz, Nicolas Castaneda & Daniel Ortiz\t" << endl;

    cout << " - Bienvenid@! -" << endl << " - Escribe 'ayuda' para ver los comandos disponibles -" << endl;

    while (true) {
        cout << "$ ";

        if (!cin.getline(linea, sizeof(linea))) 
            break;
        if (strlen(linea) == 0) 
            continue;

        // Tokeniza la línea de entrada
        char* token = strtok(linea, " ");
        char* a1 = strtok(nullptr, " ");
        char* a2 = strtok(nullptr, " ");

        if (!token) 
            continue;

        string cmd(token);
        string arg1;
        string arg2;
        int argc = 0;

        // Convertir char a string.
        if (a1 != nullptr) {
            arg1 = string(a1);
            argc++;
        }
        if (a2 != nullptr) {
            arg2 = string(a2);
            argc++;
        }

        bool encontrado = false;
        for (int i = 0; i < numComandos; ++i) {
            if (cmd == comandos[i].nombre) {
                encontrado = true;

                if (argc < comandos[i].argumentos) {
                    cout << "[ERROR] Uso: " << comandos[i].uso << endl;
                } else {
                    comandos[i].funcion(arg1, arg2);
                }

                break;
            }
        }

        if (!encontrado) {
            cout << "[ERROR] Comando invalido. Usa 'ayuda'." << endl;
        }
    }

    return 0;
}

//implementación de funciones
void ayuda(const string& arg1, const string& arg2)
{
    //valida argumentos
    if (arg1.empty()) {
        cout << "Comandos disponibles:\n";
        for (int i = 0; i < numComandos; i++) {
            cout << " - " << comandos[i].nombre << ": " << comandos[i].descripcion << endl;
        }
    } else {
        for (int i = 0; i < numComandos; i++) {
            if (comandos[i].nombre == arg1) {
                cout << "Uso de '" << arg1 << "': " << comandos[i].uso << endl;
                return;
            }
        }
        cout << "[ERROR] Comando '" << arg1 << "' no reconocido para ayuda.\n";
    }
}

void comando_cargar(const string& arg1, const string& arg2) 
{
    ifstream archivo(arg1);
    if (!archivo.is_open()) {
        cout << "[ERROR] '" << arg1 << "' no se encuentra o no puede leerse." << endl;
        return;
    }

    int secuencias = 0;
    string linea;

    while (getline(archivo, linea)) {
        if (!linea.empty()) secuencias++;
    }

    archivo.close();

    if (secuencias == 0) {
        cout << "[INFO] " << arg1 << " no contiene ninguna secuencia." << endl;
    } else if (secuencias == 1) {
        cout << "1 secuencia cargada correctamente desde " << arg1 << "." << endl;
    } else {
        cout << secuencias << " secuencias cargadas correctamente desde " << arg1 << "." << endl;
    }
}

void comando_listar_secuencias(const string& arg1, const string& arg2) //
{
    if (!arg1.empty() || !arg2.empty()) {
        cout << "[ERROR] El comando 'listar_secuencias' no recibe argumentos." << endl;
        return;
    }

    cout << "[OK] Secuencias listadas." << endl;
}

void comando_histograma(const string& arg1, const string& arg2)
{
    if (arg1.empty() || !arg2.empty()) {
    cout << "[ERROR] Uso: histograma <secuencia>" << endl;
    return;
    }

    // Generar histograma para arg1
    cout << "[OK] Histograma generado para '" << arg1 << "'." << endl;
}

void comando_subsecuencia(const string& arg1, const string& arg2)
{
    if (arg1.empty() || arg2.empty()) {
    cout << "[ERROR] Uso: es_subsecuencia <secuencia1> <secencia2>" << endl;
    return;
    }

    // Valida: ¿arg1 es subsecuencia de arg2?
    bool esSub = true; 
    if (esSub) {
        cout << "[OK] Es subsecuencia." << endl;
    } else {
        cout << "[ERROR] No es subsecuencia." << endl;
    }
}

void comando_enmascarar(const string& arg1, const string& arg2) 
{
    if (arg1.empty() || arg2.empty()) {
        cout << "[ERROR] Uso: enmascarar <secuencia> <patron>" << endl;
        return;
    }

    cout << "[OK] Regiones enmascaradas correctamente en la secuencia " << arg1 << "." << endl;
}

void comando_guardar(const string& arg1, const string& arg2) 
{
    if (arg1.empty()) {
        cout << "[ERROR] Uso: guardar <nombre_archivo>" << endl;
        return;
    }

    ofstream archivo(arg1);
    if (!archivo.is_open()) {
        cout << "[ERROR] No se pudo guardar en '" << arg1 << "'" << endl;
        return;
    }

    // Escribe en el archivo las secuencias almacenadas en memoria
    archivo.close();
    cout << "[OK] Secuencias almacenadas correctamente en " << arg1 << "." << endl;
}

void comando_codificar(const string& arg1, const string& arg2) 
{
    if (arg1.empty() || arg2.empty()) {
        cout << "[ERROR] Uso: codificar <secuencia> <clave>" << endl;
        return;
    }

    string resultado_codificado = "";

    // Muestra resultado
    cout << "[OK] Secuencia codificada: " << resultado_codificado << endl;
}

void comando_decodificar(const string& arg1, const string& arg2) 
{
    if (arg1.empty() || arg2.empty()) {
        cout << "[ERROR] Uso: decodificar <secuencia_codificada> <clave>" << endl;
        return;
    }

    string resultado_decodificado = ""; 

    // Muestra resultado
    cout << "[OK] Secuencia decodificada: " << resultado_decodificado << endl;
}

void comando_ruta_mas_corta(const string& arg1, const string& arg2) 
{
    if (arg1.empty() || arg2.empty()) {
        cout << "[ERROR] Uso: ruta_mas_corta <secuencia1> <secuencia2>" << endl;
        return;
    }

    int distancia = 0; // Calcula la distancia o pasos mínimos

    // Muestra resultado
    cout << "[OK] Ruta más corta entre '" << arg1 << "' y '" << arg2 << "': " << distancia << " pasos" << endl;
}

void comando_base_remota(const string& arg1, const string& arg2) 
{
    if (arg1.empty() || arg2.empty()) {
        cout << "[ERROR] Uso: base_remota <secuencia> <nombre_archivo>" << endl;
        return;
    }

    ifstream archivo(arg1);
    if (!archivo.is_open()) {
        cout << "[ERROR] No se pudo acceder al archivo remoto '" << arg2 << "'" << endl;
        return;
    }

    // Cargar datos desde el archivo y mostrar confirmación
    int secuencias = 0; // Cuenta cuántas secuencias hay
    string linea;
    while (getline(archivo, linea)) {
        if (!linea.empty()) secuencias++;
    }
    archivo.close();

    if (secuencias == 0) {
        cout << "[INFO] El archivo remoto no contiene ninguna secuencia." << endl;
    } else {
        cout << "[OK] " << secuencias << " secuencias cargadas desde base remota." << endl;
    }
}

void comando_salir(const string& arg1, const string& arg2) 
{
    if (!arg1.empty() || !arg2.empty()) {
        cout << "[ERROR] Uso: salir" << endl;
        return;
    }

    cout << "[OK] Saliendo del programa..." << endl;
    exit(0);  // Finaliza el programa correctamente
}